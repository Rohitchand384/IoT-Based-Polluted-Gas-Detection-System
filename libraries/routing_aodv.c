/*All rights reserved.
 *
 * Eigen Technologies Pvt. Ltd.
 * New Delhi
 * www.eigen.in
 *
 * This source code is provided to SensenutsTM  users for
 * research purpose only. No portion of this source code
 * may be used as the basis of development of any similar
 * kind of product.
 *
 */

/****************************************************************************
 * 								Very Important
 * 		This is just a reference code not ready to use in device. Final
 * 		version of AODV code will be released for final testing. Till
 * 		that time, this code should only be used for reference.
 ****************************************************************************/

#include "stdlib.h"
#include "string.h"

#include <jendefs.h>
#include <AppHardwareApi.h>

#include "AppApi.h"
#include "config.h"
#include "mac.h"
#include "node.h"
#include "routing.h"
#include "routing_aodv.h"
#include "routing_aodv_Tables.h"
#include "task.h"
#include "util.h"

//define a variable of data type AodvInfo to contain AODV related info for a node.
AodvInfo aodvInfo;

//below two statements must be included in all routing protocols
extern void userReceiveDataPacket(uint8* payload,uint8 length,uint16 prevAddr,uint8 linkQuality);

/****************************************************************************
 Function declarations used in the code
 ****************************************************************************/
void AodvUpdateLifetime(uint16 addr);

//Request related functions
void AodvGenerateRequest(uint16 destAddr);
bool AodvBroadcastRequestAsSource(uint32 seqNo,uint16 destAddr,uint8 ttl,uint32 broadcastId);
void AodvReceiveRequest(uint8* payload,uint8 length,uint16 prevAddr);

//Reply related functions
void AodvGenerateReply(uint16 srcAddr,uint16 destAddr,uint16 prevAddr,uint32 seqNo);
void AodvReceiveReply(uint8* payload,uint8 length,uint16 prevAddr);

//Error related functions
void AodvGenerateError(uint16 addr,bool noRoute);
void AodvReceiveError(uint8* payload,uint8 length,uint16 prevAddr);

/******************************************************************************
to initialize AODV routing protocol. The destination address must be known for
the usage of this routing protocol.
*******************************************************************************/
void AODVInit()
{
	/*during initialization in AODV, AodvInfo structure where all the info about the node will be maintained is initialized*/
	memset(&aodvInfo,0,sizeof(AodvInfo));
#ifdef BLACKHOLE_ATTACK
    //debug("BLACKHOLE node initiated", sizeof("blackole node initiated"));
#elif defined FFD_PAN_COORDINATOR
	//debug("PAN Coordinator initiated", sizeof ("Pan coordinator initiated"));
#else
	//debug("Coordinator initiated", sizeof ("coordinator initiated"));
#endif
}

/******************************************************************************
 send data packet using Aodv
 ******************************************************************************/
int8 AODVsendData(uint8 *data, uint8 len, uint16 destAddr)
{
	aodvRouteEntry *rtEntry=NULL;
	aodvRreqSentEntry* foundRreqStEntry=NULL;

	int i;

	bool routeAvail= AodvisRouteAvail(destAddr,&rtEntry);

	if (routeAvail)
	{
		//route found in the table. send the data and increase the life time of route
		uint8 packetToMac[MAX_STRING_LENGTH];
		/*before sending the data, add a byte info in the packet to let other nodes that this packet is a data packet
		  generated by AODV. This will help them take a decision about this packet when they receive it.
		  Also add the destination and source node address in the packet.. These additional 5 bytes make the header of data packet*/

		uint16 nodeId= getNodeId();
		packetToMac[0]=AODV_DATA;
		packetToMac[1]=nodeId<<8;
		packetToMac[2]=nodeId;
		packetToMac[3]=destAddr<<8;
		packetToMac[4]=destAddr;

		for (i = 5; i < (len+5); i++)
		{
			packetToMac[i] = *data++;
		}

		//handle contains index of destination entry in routing table and type of packet.
		uint8 macHandle=rtEntry->handle<<3|AODV_DATA;

		int8 check=sendDataToMac(packetToMac,len+5,rtEntry->nextHopAddr,macHandle,TRUE);

		AodvUpdateLifetime(destAddr);
		AodvUpdateLifetime(rtEntry->nextHopAddr);

		return check;
	}
	/*route not available. Now check if a rreq for same destination has been generated earlier or not. kernel aodv
	 * code for linux does this by looking at task queue for resend rreq. If resend rreq task is added in the queue,
	 * that means a rreq has been sent. We are doing it by making a rreq sent table. If no entry is present in rreq
	 * sent table, generate the rreq.*/
	else if (AodvFindInRreqSentTable(destAddr,&foundRreqStEntry))
	{
		//route request has already been sent. no buffering of data packet done.
		return 0;
	}
	else
	{
		//route request not generated as yet, generate it now.
		AodvGenerateRequest(destAddr);
		return 0;
	}
}


/*function called when a routing task posted by AODV earlier, expires.*/
void AODVroutingTaskHandler(taskInt taskType)
{
	//when this hits, we need to check the current task type and the node which sent the request.
	taskInt type= taskType & 0x07;

	switch (type)
	{			
		case AODV_TASK_RESEND_RREQ:
		{
			uint8 handle= taskType>>3;
			int i=0;
			int size=aodvInfo.rreqSentTableSize;
			aodvRreqSentEntry* rsEntry=NULL;

			while (i<size)
			{
				if (aodvInfo.rreqSentEntry[i].handle==handle)
				{
					rsEntry=&(aodvInfo.rreqSentEntry[i]);
					break;
				}

				i++;
			}

			if (rsEntry==NULL)
				return;					//entry not found in table so can't do anything

			uint32 broadcastId=aodvInfo.broadcastId;

			if (rsEntry->replyReceived==1 || rsEntry->times == RREQ_RETRIES)
			{
				//route already found or retry limit reached. delete entry from the table

				AodvDeleteRreqSentEntry(i);
				return;
			}
			else
			{
				//send it again, increase the number of times rreq has been generated
				AodvBroadcastRequestAsSource(aodvInfo.seqNo,rsEntry->destAddr,rsEntry->ttl+TTL_INCREMENT,++broadcastId);

				//change values in rreq sent table
				rsEntry->times++;
				rsEntry->ttl=rsEntry->ttl+TTL_INCREMENT;

				aodvInfo.broadcastId=broadcastId;

				//calculate time after which we need to check if reply was received or not
				uint32 delay=2*rsEntry->ttl*NODE_TRAVERSAL_TIME;

				addTask(ROUTING,taskType,delay);

				//seq no is not incremented while retrying the request as per aodv draft
			}

			break;
		}

		case AODV_TASK_RHE_DELETE:
		{
			uint8 handle= taskType>>3;
			int i=0;
			int size=aodvInfo.rreqHandledTableSize;
			aodvRreqHandledEntry* rhEntry=NULL;

			while (i<size)
			{
				if (aodvInfo.rreqHandledEntry[i].handle==handle)
				{
					rhEntry=&(aodvInfo.rreqHandledEntry[i]);
					break;
				}

				i++;
			}

			if (rhEntry==NULL)
				return;					//entry not found in table so can't do anything

			AodvDeleteRreqHandledEntry(i);
			break;
		}

		case AODV_TASK_BLE_DELETE:
		{
			uint8 handle= taskType>>3;
			int i=0;
			int size=aodvInfo.blacklistTableSize;
			aodvBlacklistEntry* blEntry=NULL;

			while (i<size)
			{
				if (aodvInfo.blacklistEntry[i].handle==handle)
				{
					blEntry=&(aodvInfo.blacklistEntry[i]);
					break;
				}

				i++;
			}

			if (blEntry==NULL)
				return;					//entry not found in table so can't do anything

			AodvDeleteBlacklistEntry(i);
			break;
		}

		case AODV_TASK_ROUTE_EXPIRE:
		{
			uint8 handle= taskType>>3;
			int i=0;
			int size=aodvInfo.routingTableSize;
			aodvRouteEntry* rtEntry=NULL;

			while (i<size)
			{
				if (aodvInfo.routingEntry[i].handle==handle)
				{
					rtEntry=&(aodvInfo.routingEntry[i]);
					break;
				}

				i++;
			}

			if (rtEntry==NULL)
				return;					//entry not found

			if(rtEntry->activated==0)	//entry already disabled in table so can't do anything
				return;

			if(compareTime(getCurrentTime(),rtEntry->lifetime)<=0)
			{
				rtEntry->activated=0;
				rtEntry->hopCount=NET_DIAMETER+1; //making hopcount look like infinite

				taskInt tasktype=(rtEntry->handle<<3)|AODV_TASK_ROUTE_DELETE;
				addTask(ROUTING,tasktype,DELETE_PERIOD);
			}
			else
			{
				taskInt tasktype=(rtEntry->handle<<3)|AODV_TASK_ROUTE_EXPIRE;
				addTask(ROUTING,tasktype,rtEntry->lifetime.clockLow);//subtractCurrentTime(rtEntry->lifetime));
		}

			break;
		}

		case AODV_TASK_ROUTE_DELETE:
		{
			uint8 handle= taskType>>3;
			int i=0;
			int size=aodvInfo.routingTableSize;
			aodvRouteEntry* rtEntry=NULL;

			while (i<size)
			{
				if (aodvInfo.routingEntry[i].handle==handle)
				{
					rtEntry=&(aodvInfo.routingEntry[i]);
					break;
				}

				i++;
			}

			if (rtEntry==NULL||rtEntry->activated==1)
				return;					//entry not found or already enabled in table so can't do anything

			AodvDeleteRouteEntry(i);

			break;
		}
	}
	//return 0;
}


//receive a routing packet or data packet to be relayed
void AODVreceiveDataPacket(uint8* payload,uint8 length,uint16 prevAddr,uint8 linkQuality)
{
	aodvRouteEntry *rtEntry=NULL;

	uint16 srcAddr=payload[1];
	srcAddr=(srcAddr<<8)|payload[2];
	uint16 destAddr=payload[3];
	destAddr=(destAddr<<8)|payload[4];

	if (destAddr==getNodeId())
	{
		//packet reached destination. Hand it over to user packet handler
		userReceiveDataPacket(&payload[5],length-5,prevAddr,linkQuality);
	}
	else
	{
		//need to forward the request towards destination.

		bool routeAvail= AodvisRouteAvail(destAddr,
										 &rtEntry);
#if !defined DROPPING_NODE	&& !defined BLACKHOLE_ATTACK
		if (routeAvail)
#endif		
		{
			//route found in the table. send the data and increase the life time of route

			//handle contains index of destination entry in routing table and type of packet.
			uint8 macHandle=rtEntry->handle<<3|AODV_DATA;
			
#if !defined DROPPING_NODE	&& !defined BLACKHOLE_ATTACK
            uint16 myAddr=getNodeId();
            uint16 newPacket[70];
            memcpy(newPacket,payload,length);
            memcpy(&newPacket[length],&myAddr,2);
            
			sendDataToMac(&newPacket[0],length+2,rtEntry->nextHopAddr,macHandle,TRUE);
			//debug("i am blackhole still calling this",sizeof("i am blackhole still calling this"));
#else
			ledOn();
			//debug("i am blackhole dropping packet",sizeof("i am blackhole dropping packet"));
#endif
			//update lifetime of source node and previous hop
			AodvUpdateLifetime(srcAddr);
			AodvUpdateLifetime(prevAddr);
			//blink led at intermediate node	
			/*ledOn();	
			msdelay(200);
			ledOff();*/	
			//addTask(ROUTING,0x07,500*MILLI_SECOND);

		}
#if !defined DROPPING_NODE	&& !defined BLACKHOLE_ATTACK		
		else
		{
			//if route is not available, AODV says that the error should be generated. Optionally node may try to repair this route locally.

			//currently local repair is not supported

			//generate error
//			AodvGenerateError(destAddr,TRUE);	/*true implies that the error is getting generated as there is no route, its not because next hop
												//  has dropped a packet*/
		}
#endif		
	}
}


//receive a routing packet or data packet to be relayed
void AODVreceiveControlPacket(uint8* payload,uint8 length,uint16 prevAddr,uint8 linkQuality)
{
	switch (payload[0])
	{
		case AODV_RREQ:
		{
			AodvReceiveRequest(payload,length,prevAddr);
			break;
		}
		case AODV_RREP:
		{
			AodvReceiveReply(payload,length,prevAddr);
			break;
		}
		case AODV_RERR:
		{
			AodvReceiveError(payload,length,prevAddr);
			break;
		}
	}

}


//handle route error
void AODVhandleError(uint8 u8Handle)
{
	uint8 handle=u8Handle>>3;
	uint8 packetType=u8Handle & 0x07;

	int i=0;
	int size=aodvInfo.routingTableSize;
	aodvRouteEntry* rtEntry=NULL;
	aodvRouteEntry* foundRtEntry=NULL;

	while (i<size)
	{
		if (aodvInfo.routingEntry[i].handle==handle)
		{
			rtEntry=&(aodvInfo.routingEntry[i]);
			break;
		}

		i++;
	}

	if (rtEntry==NULL)
		return;

	if (packetType==AODV_RREP)
	{
		//add next hop in blacklist table
		AodvInsertBlacklistTable(rtEntry->destAddr);

		//it makes sense to disable route to next hop (at least) here but its not mentioned in RFC 3561 so not implementing
	}
	else if (packetType==AODV_DATA)
	{
		//generate error
		AodvGenerateError(rtEntry->nextHopAddr,FALSE);

		//disable route to both, this destination and the next hop

		rtEntry->activated=0;
		rtEntry->hopCount=NET_DIAMETER+1; //making hopcount look like infinite

		taskInt tasktype=(rtEntry->handle<<3)|AODV_TASK_ROUTE_DELETE;
		addTask(ROUTING,tasktype,DELETE_PERIOD);

		//find next hop entry

		bool routeAvail= AodvisRouteAvail(rtEntry->nextHopAddr,
						 	 	 	 	  &foundRtEntry);

		if(!routeAvail)
			return;

		foundRtEntry->activated=0;
		foundRtEntry->hopCount=NET_DIAMETER+1; //making hopcount look like infinite

		tasktype=(foundRtEntry->handle<<3)|AODV_TASK_ROUTE_DELETE;
		addTask(ROUTING,tasktype,DELETE_PERIOD);
	}

}

//update the life time of a destination entry in routing table
void AodvUpdateLifetime(uint16 addr)
{
	aodvRouteEntry* rtEntry=NULL;

	bool routeAvail= AodvisRouteAvail(addr,
				 	 	 	 	 	 &rtEntry);

	if (routeAvail)
		addTimeInCurrent(&(rtEntry->lifetime),ACTIVE_ROUTE_TIMEOUT);
	else
	{	//something very wrong

	}
}

/*****************************************************************************
 * Request related functions
 * ***************************************************************************/
void AodvGenerateRequest(uint16 destAddr)
{
	//ledOn();
	taskInt taskType=0;

	uint32 seqNo=aodvInfo.seqNo;
	uint32 broadcastId=aodvInfo.broadcastId;

	bool check=AodvBroadcastRequestAsSource(seqNo,destAddr,TTL_START,broadcastId);

	//add a task to check after 2*ttl*Node traversal time to check whether reply was received for this req or not.

	if (check)
	{
		//add entry in rreq sent table
		int8 handle =AodvInsertRreqSentTable(destAddr,
						     TTL_START,
						     1);

		// no room in sent table, so do not proceed.
		if (handle==-1)
		{
			return;
		}

		//add entry in rreq handled table so that when this node receives the same requests again, it can discard it
		AodvInsertRreqHandledEntry(broadcastId,
#ifdef FFD_PAN_COORDINATOR
					   0);
#else
		  	  	  	   getNodeId());
#endif


		//add a task to check after 2*TTL*Node traversal time, whether reply was received or not.

		/*first five bits of task type will represent the index num of destination in sent table. The last 3 bits represents the event type*/

		taskType=(handle<<3)|AODV_TASK_RESEND_RREQ;

		//calculate time after which we need to check if reply was received or not
		uint32 delay=2*TTL_START*NODE_TRAVERSAL_TIME;

		addTask(ROUTING,taskType,delay);

		seqNo++;
		broadcastId++;
		memcpy(&(aodvInfo.seqNo),&seqNo,4);
		memcpy(&(aodvInfo.broadcastId),&broadcastId,4);

		return;
	}
	//if this is hit that will mean that rreq packet size is going beyond 80 bytes. This info is for those, who might change this code
	return;
}

bool AodvBroadcastRequestAsSource(uint32 seqNo,uint16 destAddr,uint8 ttl,uint32 broadcastId)
{
	//fill the packet information
	bool check=0;
	aodvRouteEntry *rtEntry=NULL;
	aodvRreqPkt rreqPkt;

	bool routeAvail= AodvGetRouteEntry(destAddr,
									  &rtEntry);

	rreqPkt.type=AODV_RREQ;

	/*J and R flag are reserved for multicast. So setting them to 0.
	 *G flag is also set to 0 as gratituous reply will never be done
	 *as D flag will be set to 1 always, which means that only destination
	 *can reply to a request. U flag decided in next step.*/

	rreqPkt.JRGDUReserved=0x10;

	if (!routeAvail)
	{
		rreqPkt.JRGDUReserved |=0x08; //setting the U flag as destination seq number is not known.
		rreqPkt.dst_seq=0;
	}
	else
	{
		rreqPkt.dst_seq=seqNo;
	}

	rreqPkt.Reserved=0;
	rreqPkt.hopCount=0;
	rreqPkt.srcAddr=getNodeId();
	rreqPkt.destAddr=destAddr;
	rreqPkt.rreq_Id=broadcastId;
	rreqPkt.src_seq=seqNo;
	rreqPkt.ttl=ttl;

	//send rreq packet formed to mac layer to broadcast it in the network after typecasting the packet to uint8*
	check=sendDataToMac((uint8*)&rreqPkt,sizeof(aodvRreqPkt),0xFFFF,AODV_RREQ,FALSE);
    //debug((uint8*)&rreqPkt,sizeof(aodvRreqPkt));
	return check;
}

void AodvReceiveRequest(uint8* payload,uint8 length,uint16 prevAddr)
{
	aodvRouteEntry *rtEntry=NULL;
	uint32 seqNo=aodvInfo.seqNo;

	aodvRreqPkt *rreqPkt=(aodvRreqPkt*)payload;

	/*1) check whether the previous hop is in black list table or not. If it is present in blacklist table, drop the request.
	  2) check if hopcount > network diameter, if it is true, drop the request.
	  3) check if a similar request has been handled earlier by this node. If yes, drop the request.*/

	if (AodvFindInBlacklistTable(prevAddr)
		|| rreqPkt->hopCount > NET_DIAMETER
		|| AodvFindInRreqHandleTable(rreqPkt->srcAddr,rreqPkt->rreq_Id))
	{
		//ledOn();
		//debug("dropping request",sizeof("dropping request"));
		//debug(&prevAddr,2);
		return;
	}

	// put the info about current packet in in rreq handle table

	AodvInsertRreqHandledEntry(rreqPkt->rreq_Id,rreqPkt->srcAddr);

	// make entry in the routing table of both source node and previous node

	bool routeAvail= AodvGetRouteEntry(rreqPkt->srcAddr,
									   &rtEntry);

	//first of all we need to make sure that a better entry of source is not already present in the table. If it is not there, then only make this entry

	if (!routeAvail||!rtEntry->activated
		|| rtEntry->seqNo-rreqPkt->src_seq < 0
		|| (rtEntry->seqNo==rreqPkt->src_seq
			&& rtEntry->hopCount > rreqPkt->hopCount)
		)
	{
		AodvInsertUpdateRoute(rreqPkt->src_seq,
							  ACTIVE_ROUTE_TIMEOUT,
							  rreqPkt->srcAddr,
							  prevAddr,
							  rreqPkt->hopCount+1);
	}

	if (prevAddr!=rreqPkt->srcAddr)
	{
		AodvInsertUpdateRoute(0,							//for neighbours seq no is set to 0 if it is not known already
							  ACTIVE_ROUTE_TIMEOUT,
							  prevAddr,
							  prevAddr,
							  1);
	}

	//check if this request is for me or not
#ifndef BLACKHOLE_ATTACK
	if (rreqPkt->destAddr==getNodeId())
#endif    	
	{
		//yippie found the destination. generate the reply

		//update the destination seq number with greater value between seq no in packet and that of the node itself

		if (rreqPkt->dst_seq>seqNo)
			seqNo=rreqPkt->dst_seq;
        
		AodvGenerateReply(rreqPkt->srcAddr,rreqPkt->destAddr,prevAddr,seqNo);

	}
#ifndef BLACKHOLE_ATTACK	
	else
	{
		/*As per AODV draft, here we are supposed to check if the D flag is set in the packet or not. If it is not set, the
		 * node can try to find out if it already knows the destinations route or not. If it is available, this node can then generate
		 * a reply as intermediate node towards the source, telling that the data can be sent through this. Also, it needs to check if
		 * G flag is also set in the packet or not. If G flag is set, a gratituous reply is also to be genrated towards the destination
		 * telling it that this node a generated a reply on destinations behalf.*/

		/*In current implementation, D flag is always set, so no need to check, only destination will reply to source's request */


		//forward the request if ttl >1, after incrementing the hop count, decrementing the ttl

		if (rreqPkt->ttl > 1)
		{
			rreqPkt->ttl--;
			rreqPkt->hopCount++;

			sendDataToMac((uint8*)rreqPkt,sizeof(aodvRreqPkt),0xFFFF,AODV_RREQ,FALSE);
		}
	}
#endif

#ifdef BLACKHOLE_ATTACK
    aodvInfo.seqNo=310000;
    //debug("i am blackhole. sending higher seq no.",sizeof("i am blackhole. sending higher seq no."));
#else
	aodvInfo.seqNo=seqNo;
#endif
	//done here
}

/***************************************************************************
 * Reply Related Functions
 **************************************************************************/

void AodvGenerateReply(uint16 srcAddr,uint16 destAddr,uint16 prevAddr,uint32 seqNo)
{
	aodvRrepPkt rrepPkt;
	aodvRouteEntry *rtEntry=NULL;

	AodvisRouteAvail(srcAddr,
					 &rtEntry);

	//entry of srcAddr will definitely be there. so no need to worry.

	rrepPkt.type=AODV_RREP;

	//R flag is for multicast. Also, acknowledgement is not requested.
	rrepPkt.RAReserved=0;
    rrepPkt.ReservedPrefixSize=0;
	rrepPkt.hopCount=0;		//destination node sets hopcount 0

	rrepPkt.dstAddr=destAddr;
	rrepPkt.orgAddr=srcAddr;
#ifndef BLACKHOLE_ATTACK	
	rrepPkt.dst_seq=seqNo;
	rrepPkt.lifetime=MY_ROUTE_TIMEOUT;
#else
    rrepPkt.dst_seq=3100000; //put very high value
	rrepPkt.lifetime=3100000;
#endif
	//lets select a handle in case packet gets dropped, our node will use the handle to know which packet got dropped and for which node

	//first 5 bits define which node is in question and last three represents the type of packet generated.
	uint8 macHandle=(rtEntry->handle<<5)|AODV_RREP;

#ifdef BLACKHOLE_ATTACK
    //msdelay(10);
    //debug("generating false reply",sizeof("generating false reply"));
    //msdelay(10);
	//debug((uint8*)&rrepPkt,sizeof(aodvRrepPkt));
#endif
	sendDataToMac((uint8*)&rrepPkt,sizeof(aodvRrepPkt),prevAddr,macHandle,TRUE);
}


void AodvReceiveReply(uint8* payload,uint8 length,uint16 prevAddr)
{
    //debug("dupdating route",sizeof("dupdating route"));
    //debug(&prevAddr,2);
    //msdelay(10);
    //debug(payload,length);
    //msdelay(10);
	aodvRouteEntry *rtEntry=NULL;

	aodvRreqSentEntry* foundRSEntry=NULL;

	aodvRrepPkt *rrepPkt=(aodvRrepPkt*)payload;

	//check if hopcount is greater than network diameter, if yes, drop the packet

	if(rrepPkt->hopCount+1 > NET_DIAMETER)
	{
	    //debug("dropping route",sizeof("dropping route"));
        //debug(&prevAddr,2);
        //msdelay(10);
		return;
	}

#ifdef FFD_PAN_COORDINATOR
	if (rrepPkt->orgAddr!=0)
#else
	if (rrepPkt->orgAddr!=getNodeId())
#endif
	{
	    //debug("relay route",sizeof("relay route"));
        //debug(&prevAddr,2);
        msdelay(10);
		//need to forward the request towards originator
		rrepPkt->hopCount++;

		bool routeAvail= AodvisRouteAvail(rrepPkt->orgAddr,
									 	 &rtEntry);


		if (routeAvail)
		{
			//first 5 bits define which node is in question and last three represents the type of packet generated.
			uint8 macHandle=(rtEntry->handle<<5)|AODV_RREP;

			sendDataToMac((uint8*)rrepPkt,sizeof(aodvRrepPkt),rtEntry->nextHopAddr,macHandle,TRUE);
		}
	}
	else
	{
		bool entryAvail= AodvFindInRreqSentTable(rrepPkt->dstAddr,
				 	 	 	 	 	 	 	 	 &foundRSEntry);

		if (entryAvail==TRUE)
		{
			//update in sent table that the reply has been received
			foundRSEntry->replyReceived=1;
		}
		else
		{
			//its either a late reply or false reply. In any case drop the packet
			//debug("not in sent table",sizeof("not in sent table"));
            //debug(&prevAddr,2);
            msdelay(10);
			return;
		}
	}

	//update the route entry with prevAddr and destination address
	if (prevAddr!=rrepPkt->dstAddr)
	{
		AodvInsertUpdateRoute(0,							//for neighbours seq no is set to 0 if it is not known already
							  ACTIVE_ROUTE_TIMEOUT,
							  prevAddr,
							  prevAddr,
							  1);
	}

	// make entry in the routing table of both source node and previous node

	bool routeAvail= AodvGetRouteEntry(rrepPkt->dstAddr,
									   &rtEntry);

	if (!routeAvail
		|| rtEntry->seqNo<rrepPkt->dst_seq
		|| (rtEntry->seqNo==rrepPkt->dst_seq
		   && rtEntry->hopCount > rrepPkt->hopCount)
	   )
	{
		//ledOn();
		//debug("updating route",sizeof("updating route"));
		//debug(&prevAddr,2);
		AodvInsertUpdateRoute(rrepPkt->dst_seq,
							  rrepPkt->lifetime,
							  rrepPkt->dstAddr,
							  prevAddr,
							  rrepPkt->hopCount+1);
	}
	else
	{
	} //   debug("wrong here route",sizeof("wrong here route"));
}


/***********************************************************************************
Route Error related functions
************************************************************************************/
void AodvGenerateError(uint16 addr,bool noRoute)
{
	uint32 seqNum;
	aodvRouteEntry *rtEntry=NULL;

	//We can't allow a packet of size greater than 80 bytes to reach mac layer as it is bound to drop it. So rerr will be created accordingly.
	uint8 rerrPkt[80];
	uint8 rerrSize=4; //this is default size of Rerr. It will further increase depending on the destination info added in packet.

	/*lets start putting info in packet. The packet format is
	uint8 type;
    uint8 NReserved; //1 bit for N flag, 7 reserved bits	N bit is used whien local repair is done. Here it is always set to 0
    uint8 reserved;
    uint8 destCount;*/

	rerrPkt[0]=AODV_RERR;
	rerrPkt[1]=0;
	rerrPkt[2]=0;
	rerrPkt[3]=0;

	if (noRoute)
	{
		//addr has destination address which can't be reached. send info about this destination only
		bool routeAvail= AodvGetRouteEntry(addr,
										  &rtEntry);

		if (!routeAvail)
		{
			seqNum=0;
		}
		else
		{
			seqNum=rtEntry->seqNo;
		}

		rerrPkt[4]=addr>>8;
		rerrPkt[5]=addr;
		rerrPkt[6]=seqNum>>24;
		rerrPkt[7]=(seqNum>>16)|0x000000FF;
		rerrPkt[8]=(seqNum>>8)|0x000000FF;
		rerrPkt[9]=(seqNum)|0x000000FF;
		rerrPkt[3]++;
		rerrSize+=6; //6 bytes added
	}
	else
	{
		//addr has next hop info which dropped the packet. Find all the destinations that use this as next hop and then add their info in rerrpacket
		int j=4;

		int i=0;
		int size=aodvInfo.routingTableSize;

		while(i<size)
		{
			if (rerrSize>=80)
			{
				/*info about no more destination address can be added in the packet. We could break here and try to send the info collected
				 till now or we can return here and inform the ueser may be through led about the problem the node is in.

				 choosing to return here.*/
				return;
			}

			if (aodvInfo.routingEntry[i].nextHopAddr==addr)
			{
				rerrPkt[j++]=aodvInfo.routingEntry[i].destAddr>>8;
				rerrPkt[j++]=aodvInfo.routingEntry[i].destAddr;
				rerrPkt[j++]=aodvInfo.routingEntry[i].seqNo>>24;
				rerrPkt[j++]=(aodvInfo.routingEntry[i].seqNo>>16)|0x000000FF;
				rerrPkt[j++]=(aodvInfo.routingEntry[i].seqNo>>8)|0x000000FF;
				rerrPkt[j++]=(aodvInfo.routingEntry[i].seqNo)|0x000000FF;
				rerrPkt[3]++;
				rerrSize+=6; //6 bytes added
			}
			i++;
		}
	}

	sendDataToMac(rerrPkt,rerrSize,0xFFFF,AODV_RERR,FALSE);	//handle is not important here. So just sending packet type
}


void AodvReceiveError(uint8* payload,uint8 length,uint16 prevAddr)
{
	int i,j=4,k=4;
	uint16 destAddr;
	uint8 outgoingRerrPkt[80];
	uint8 count=0;
	uint8 outgoingRerrSize=4;

	aodvRouteEntry *rtEntry=NULL;

	for (i = 0; i < payload[3]; i++)		//payload[3] contains the destination count
	{
	   //go through all the unreachable destinations in the rerr

		destAddr=payload[j++];
		destAddr=(destAddr<<8)|payload[j++];

		bool routeAvail= AodvisRouteAvail(destAddr,
										  &rtEntry);

		if (routeAvail&&rtEntry->nextHopAddr==prevAddr)
		{
			//we are using next hop only to reach this destination. disable route and add an entry in the outgoing rerr packet
			rtEntry->activated=0;
			rtEntry->hopCount=NET_DIAMETER+1; //making hopcount look like infinite

			taskInt tasktype=(rtEntry->handle<<3)|AODV_TASK_ROUTE_DELETE;
			addTask(ROUTING,tasktype,DELETE_PERIOD);

			outgoingRerrPkt[k++]=destAddr<<8;
			outgoingRerrPkt[k++]=destAddr;
			outgoingRerrPkt[k++]=payload[j++];
			outgoingRerrPkt[k++]=payload[j++];
			outgoingRerrPkt[k++]=payload[j++];
			outgoingRerrPkt[k++]=payload[j++];
			count++;
			outgoingRerrSize+=6;
		}
		else
			j=j+4;
	}

	if (outgoingRerrSize>4)
	{
		outgoingRerrPkt[0]=AODV_RERR;
		outgoingRerrPkt[1]=0;
		outgoingRerrPkt[2]=0;
		outgoingRerrPkt[3]=count;
		sendDataToMac(outgoingRerrPkt,outgoingRerrSize,0xFFFF,AODV_RERR,FALSE);	//handle is not important here. So just sending packet type
	}
}
