/*All rights reserved.
 *
 * Eigen Technologies Pvt. Ltd.
 * New Delhi
 * www.eigen.in
 *
 * This source code is provided to SensenutsTM  users for
 * research purpose only. No portion of this source code
 * may be used as the basis of development of any similar
 * kind of product.
 *
 */

#include <jendefs.h>
#include <stdio.h>
#include <string.h>
#include "config.h"

#ifdef ACCELEROMETER_ENABLE

#include "pcInterface.h"
#include "util.h"
#include "task.h"
#include "node.h"
#include "dio.h"
#include "i2c.h"
#include "Accelerometer.h"
#include "mac.h"
int8 AccOutData[6];
extern void sendAccToGUI(uint16 nodeId ,uint8* string,uint8 length);
/* Initlizes the starting conditions of Accelerometer */


void accelerometer_Init(uint8 Accl_mode)
{

	i2cInit();
	//device address in 8 bits
	accelerometer_Standby_mode();
	//to configure the mode of acceleromter
	i2cWrite(0x1d, XYZ_DATA_CFG);
	//Select the mode in which device is going to working
	//Modes: 2G,4G,8G
	i2cWriteAndStop(Accl_mode);
	//move to active mode
	accelerometer_Acive_mode();

}

/* To move in standby mode
 *  All analog parts of device are in off state*/

void accelerometer_Standby_mode()
{
    i2cWrite(0x1d, CTRL_REG1);

    i2cWriteAndStop(0x00);
}

/* to change the device from standby mode to active mode
  * all analog as well as digital part are accessiable */

void accelerometer_Acive_mode()
{

    i2cWrite(0x1d, CTRL_REG1);
    //set output data rate of accelerometer
    i2cWriteAndStop(0x19);
    //i2cWriteAndStop(0x31);

}

/*  To test device is properly working it will print value 0x1A  */

void WHO_AM_I_test()
{

	//uint8 read;
	//write the i2c address and the control register address
	i2cWrite(0x1d, WHO_AM_I);
	//read data
	i2cRequestData (0x1d);
	//read = i2cReadStop();
	i2cReadStop();
	//print data on the Gui it must be 0x1A
    //	debug(&read , 1);

}

/* To enable interrupt if some data is available */

void Accelerometer_Interrupt_Enable(){

	accelerometer_Standby_mode();
	//write the i2c address and the control register address
	i2cWrite(0x1d, CTRL_REG4);
	i2cWriteAndStop(0x01);
	i2cWrite(0x1d, CTRL_REG5);
	i2cWriteAndStop(0x01);
	//To move into active state
	accelerometer_Acive_mode();

}

/* To disable interrupt due to acceleromter */

void Accelerometer_Interrupt_Disable(){

	accelerometer_Standby_mode();
	//write the i2c address and the control register address
	i2cWrite(0x1d, CTRL_REG4);
	i2cWriteAndStop(0x00);
	i2cWrite(0x1d, CTRL_REG5);
	i2cWriteAndStop(0x00);
	//To move into active mode
	accelerometer_Acive_mode();

}

/* To the value of acceleration in x direction
 *  both + and -tive value of acceleration are printed */

void read_xValue()
{

	//uint16 xValue;
	i2cWrite(0x1d, OUT_X_MSB);
	i2cRequestData(0x1d);
	AccOutData[0] = i2cReadStop();
	i2cWrite(0x1d, OUT_X_LSB);
	i2cRequestData(0x1d);
	AccOutData[1] = i2cReadStop();

}

/* To print value of Y direction data */

void read_yValue()
{

	//uint16 yValue;
	i2cWrite(0x1d, OUT_Y_MSB);
	i2cRequestData(0x1d);
	AccOutData[2] = i2cReadStop();
	i2cWrite(0x1d, OUT_Y_LSB);
	i2cRequestData(0x1d);
	AccOutData[3] = i2cReadStop();

}

/* To print the value of acceleration in z direction */

void read_zValue()
{

	//uint16 zValue;
	i2cWrite(0x1d, OUT_Z_MSB);
	i2cRequestData(0x1d);
	AccOutData[4] = i2cReadStop();
	i2cWrite(0x1d, OUT_Z_LSB);
	i2cRequestData(0x1d);
	AccOutData[5] = i2cReadStop();

}

/* this is used to send acc data wireless*/

void getUpdateAcc()
{
	//bool check;
	uint8 sendAccData[7];
	read_xValue();
	read_yValue();
	read_zValue();
	sendAccData[0] = 0x60;
	memcpy (&sendAccData[1] , &AccOutData[0] ,6);
	sendAccToGUI(getNodeId(),&sendAccData[1],6);
	//debug(&sendAccData,7);
	//check=sendDataToMac(sendAccData,7,0xFFFF,0,FALSE);	//16 bit broadcast address with no ack req. Mac ack should be disabled
														//when broadcast is done.
													
													
/*	if (check==FALSE)*/
/*	{*/
/*		*/
/*	}*/


}

/* To initlizes interrupt due of Accelerometer */

void acclerometer_Interrupt_Init()
{

	vAHI_DioSetDirection(0x00000001<<8,
							  0x00000000);

	vAHI_DioInterruptEdge(0x00000000,
				              0x00000001<<8);

	vAHI_DioWakeEnable(0x00000001<<8,
						      0x00000000);

	vAHI_DioWakeEdge(0x00000000,
						      0x00000001<<8);

	vAHI_DioInterruptEnable(0x00000001<<8,
							  0x00000000);

	vAHI_SysCtrlRegisterCallback(Accelerometer_Interrupt_Handler);

}

/* Interrupt Handler for interrupt generated by Accelerometer */

void Accelerometer_Interrupt_Handler()
{
	Accelerometer_Interrupt_Disable();
	vAHI_DioInterruptEnable(0x00000000,
								  0x00000001<<8);
	accelerometer_Acive_mode();
		
	printfData();
	msdelay(100);
	vAHI_DioInterruptEnable(0x00000001<<8,
								  0x00000000);
	Accelerometer_Interrupt_Enable();
}

#endif